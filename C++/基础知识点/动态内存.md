# 动态内存


> 静态内存用来保存局部 `static` 对象、类 `static` 数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非 `static` 对象。分配在静态或者栈内存中的对象由编译器自动创建和销毁。对于栈对象仅在其定义的程序块中可运行时才存在； `static` 对象在使用之前分配，在程序结束时销毁。

> 除了静态内存和栈内存，每个程序还有一个内存池。这部分被称为自由空间或堆。程序用堆来存储动态分配的对象。动态对象的生存期由程序来控制，也必须由我们显式的来销毁。

## 动态内存的管理
在 `C++` 中是通过 `new` 和 `delete` 来完成的。

 

> `new`
在动态内存中为对象分配空间并返回一个指向该对象的指针，可以选择为对象进行初始化。

> `delete`
> 接受一个动态对象的指针，销毁该对象，并释放与之相关的内存。

动态内存的使用很容易出现问题，原因在于难以确保在正确的时间释放内存。如果忘记释放内存会造成内存泄漏，如果在还有指针引用内存的情况下，释放了与之关联的内存，会产生引用非法内存的指针。

## 智能指针
为了更容易更安全的使用动态内存，新的标准提供了两种智能指针类型来管理动态对象。智能指针类似常规指针，不过它可以自动释放所指向的对象。两种智能指针的区别在于： `shared_ptr` 允许多个指针指向同一对象； `unique_ptr` 则独占所指对象。标准库还定义了 `weak_ptr` 一种弱引用来指向 `shared_ptr` 所管理的对象。所有的智能指针都定义在 `memory` 头文件中。

### shared_ptr
类似 `vector` ，智能指针也是模板。创建智能指针时也和模板类一样：


    shared_ptr<string> p1; // shared_ptr指向string

默认初始化的智能指针保存着一个空指针。智能指针使用和普通指针类似，解引用返回所指向的对象。

使用 `make_shared` 函数来初始化 `shared_ptr`是最安全的方法：


    make_shared<T> (args); // 返回一个shared_ptr，指向一个T类型的对象，初始值为args.

每个 `shared_ptr` 都有一个关联的计数器，称为引用计数。用来记录有多少个指针共享对象，每次拷贝计数器都会递增，每次对 `shared_ptr` 赋予新值或被销毁，计数器都会递减。

当指向对象的最后一个 `shared_ptr` 被销毁时，会自动销毁此对象。也就会计数器为 0 的时候会自动调用析构函数来销毁对象，释放占用的内存。

不要混用普通指针和智能指针。

> 补充：
> 
> 程序使用动态内存的情况：
> 
- 不知道需要使用多少对象
- 不知道对象的具体类型
- 需要在多个对象间共享数据

> 智能指针使用规范：
> 
- 不使用相同的内置指针初始化多个智能指针
- 不delete get()返回的指针
- 不使用 get() 初始化或reset另一个智能指针
- 如果使用get()返回的指针，当最后一个对应的智能指针销毁后，指针就变为无效了
- 如果使用智能指针管理的资源不是 new 分配的内存，需要传递给它一个删除器


## new 和 delete


> 使用 `new` 动态分配和初始化对象

在自由空间分配的内存是无名的，所以无法为分配的对象命名，返回一个指向该对象的指针。

    int *p = new int; // 指向一个动态分配的、未初始化的无名对象。

> 使用 delete 释放动态内存

 `delete` 表达式接受一个指针，指向我们想要释放的对象。然后会执行销毁给定指针指向的对象并释放对应的内存。传递的指针必须是指向动态内存的指针或者是一个空指针。释放一块没动态分配的内存，或者相同的指针释放多次，会产生未定义操作。



> 补充：使用 new 和 delete 的三个常见问题：
> 
- 忘记 delete，也就是内存泄漏，要查找内存泄漏是很困难的，只有到了内存耗尽时才能检测到这种错误。
- 使用已经释放掉的对象。释放后的将指针置为空，有时可以检测出这种错误。
- 同一块内存释放两次。有两个指针都指向相同的动态分配对象时，可能发生这种错误。

 `delete`一个指针后，指针值就变为无效了，不过很多机器上指针依然保留原来的动态内存地址，变为了空悬指针。可以通过重置指针为空来避免这个问题。



