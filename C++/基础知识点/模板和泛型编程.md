# 模板和泛型编程

> 面向对象编程（OOP）和泛型编程都能够处理在编写程序时不知道类型的情况，不同之处在于OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型。

----------

## 模板
> 模板是泛型编程的基础。
> 
> 一个模板就是一个创建类或者函数的蓝图或者公式（就像一个模具，无论倒进去什么材料，都会产生特定的形状）


----------
### 定义模板
> 函数模板：
> 
> 可以定义一个通用的函数模板，每个类型都可以通过这个函数模板来生成对应类型的函数版本。

> 模板的定义以关键字 `template` 开始，后面跟着是一个模板参数列表，用 `<>` 括起来，中间有一个或者多个模板参数。（在模板定义中，模板参数列表不能为空）

> 编译器会通过函数实参来推断模板实参，然后生成相应的实例。

> 我们可以将模板类型参数作为类型说明符来使用，作为函数返回类型或者函数参数类型，以及在函数体内用于变量声明或类型转换。

> 类型参数之前必须使用关键字 `class` 或 `typename` ，在模板参数列表中这两个关键字含义相同，可以互换使用，一个模板参数列表中可以同时使用这两个关键字。 `typename` 看起来更直观，一般使用内置类型作为模板参数的时候使用，如果使用自定义类可以使用 `class`。

> 除了定义类型参数，还可以在模板中定义非类型模板参数。一个非类型模板参数表示一个值而非一个类型，可以是一个整数型或者一个指向对象或函数类型的指针或引用，绑定到非类型参数的实参必须是一个常量表达式，绑定到指针或引用的实参必须具有静态的生存期。


----------
> 编写类型无关的代码：
> 
- 模板中的函数参数是const引用，保证函数可以用于不能拷贝的类型。
- 函数体中的条件判断仅使用 `<` 比较运算，降低函数对要处理的类型的要求。

> 模板程序应该尽量减少对实参类型的要求。


----------
> 模板编译：
> 
> 当编译器遇到一个模板定义时，并不生成代码，只有当实例化出模板的一个特定版本的时候，才会生成代码。所以为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，模板的头文件通常包括声明和定义。

> 通常编译器会在三个阶段报告错误：
> 
1. 编译模板本身，检查语法错误，通常没什么问题
2. 编译器遇到模板使用时，检查实参数目是否正确，类型是否匹配
3. 模板实例化时，只有这个阶段才能发现类型相关的错误，这类错误可能在链接时才报告


----------
> 类模板

> 与函数模板不同，编译器不能为类模板推断参数类型。

> 类模板也是以关键字 `template` 开始，后跟模板参数列表。当使用一个类模板时需要提供额外信息，这些额外信息是显式模板实参列表，它们被绑定到模板参数，编译器使用这些模板实参来实例化出特定的类。

