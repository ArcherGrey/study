# 面向对象程序设计（OOP）
面向对象程序设计的核心思想是：

- 数据抽象：将类的接口和实现分离
- 继承：定义相似的类型并对其相似关系建模
- 动态绑定：一定程度上忽略相似的类的区别，通过统一的方式使用它们的对象


----------
> 继承

通过继承联系在一起的类构成一种层次关系。通常这种层次关系有一个共有的基类，其他类都是直接或间接的由基类继承而来。这些继承而来的类称为派生类。基类负责定义在层次关系中所有类共有的成员。

如果某些派生类对于基类中的共有操作需要有自己的定义，则可以将基类中对应的操作声明为虚函数，然后在派生类中对所有需要重新定义的虚函数进行声明，派生类中重新定义的虚函数可以加virual关键字，也可以不加。

----------
> 动态绑定

动态绑定是将一个过程调用与相应代码链接起来的行为。是指与给定的过程调用相关联的代码，只有在运行期才可知的一种绑定，他是多态实现的具体形式。

C++中，通过基类的引用或指针调用虚函数时，发生动态绑定。引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。

动态绑定在函数调用时需要在虚函数表中查找，所以性能比静态函数调用稍低。

通过基类类型的指针访问派生类自己的虚函数将发生错误。

----------
> 访问控制和继承

某些时候基类希望派生类可以访问该成员，但是其他用户不能访问，这时候需要使用受保护(public)访问运算符来说明。

----------
> 派生类向基类的类型转换

可以把派生类对象当做基类对象来使用，可以把基类指针或引用绑定到派生类对象中的基类部分上。派生类到基类的类型转换时隐式的。

例如：

    A a; //基类对象
    B b; //派生类对象
    A *aa=&a; //指向基类对象
    aa=&b; //指向派生类对象的基类部分
    A &aaa=b; //绑定派生类对象的基类部分


----------
> 派生类构造函数

派生类需要使用基类的构造函数来初始化自己的基类部分。

派生类构造函数调用基类构造函数初始化基类部分，然后按声明顺序依次初始化派生类成员。

例子：

    // A为基类，B为派生类
    B(int a,int b,int c):A(a,b){
    	this.c=c;
    }


----------
> 防止继承

有些类我们不希望被其他类继承，可以在类名后面加关键字final。


----------
> 继承关系的类之间的类型转换有下面几点需要注意：
> 
- 从派生类到基类的类型转换只对引用或者指针有效
- 基类到派生类不存在隐式类型转换
- 派生类到基类的类型转换也可能会因为访问受限而不可行

