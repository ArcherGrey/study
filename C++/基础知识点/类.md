# 类
> 类的基本思想：数据抽象 + 封装。

> 数据抽象：将接口和实现分离的编程技术。接口包括用户所能执行的操作，实现包括类的数据成员，接口实现的函数，私有函数。
> 封装：隐藏了实现的细节，也就是可以使用接口，但是无法了解实现细节。

## 构造函数
> 默认的构造函数：如果一个类没有显式的定义任何构造函数，编译器会隐式的定义一个默认构造函数。
> 
> 默认构造函数会按照下面的规则初始化类的数据成员：
> 
- 如果存在类内的初始值，用它来初始化成员。
- 否则默认初始化。

> 默认构造函数只适合非常简单的类，默认构造函数可能会将成员初始化为一些未定义的值，导致错误。如果类中包含其他类的成员且成员的类没有默认构造函数，则编译器无法初始化该成员。如果需要默认的行为可以在参数列表的后面加上 `=default`。


----------
## 访问控制和封装
> 通过访问说明符来实现类的封装性：
> 
- `public`之后的成员可以在整个程序内被访问，一般用来定义类的接口。
- `private` 说明符之后的成员可以被类的成员函数访问，但是不能使用该类的代码访问，部分封装了类的实现细节。


----------

>  `class` 的默认成员是 `private`的， `struct` 是 `public`。（前面是两者之间的唯一区别，C++中 `struct`也可以添加成员函数)

----------

> 友元
> 
类可以允许其他类或者函数访问它的非公有成员，方法就是令其他类或者函数成为它的友元。只需要在类中增加一条以 `friend` 开头的声明语句即可。



> 最好在类定义开始或者结束的位置集中声明友元。



> 友元声明仅仅是指定访问权限，而不是通常意义上的声明。


----------
## 类的其他特性
一个 `const` 成员函数如果以引用的方式返回 `*this`，那么返回类型是常量引用。

即使两个类的成员列表完全一样，它们也是不同的类型。

只声明不定义的类是不完全类型，不能创建类的对象，这种声明叫前向声明。

----------
## 类的作用域
一个类就是一个作用域。

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域使用过，不过在类中，如果成员使用了外层作用域的某个名字，该名字代表一种类型，则类不能在之后重新定义该名字。

----------
## 构造函数
最好使用构造函数初始化，如果没有初始化列表，效率比较低。

最好令初始值的顺序和成员声明顺序保持一致，尽量避免用某些成员初始化其他成员。

如果一个构造函数为所有参数都提供了默认值，那么实际上就是默认构造函数。

对象被默认初始化或值初始化时自动执行默认构造函数，默认初始化在下面情况发生：

- 在块作用域内不使用任何初始值定义一个非静态变量或者数组时
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时
- 当类类型的成员没有在构造函数初始值列表中显式初始化时

值初始化在下面情况发生：

- 在数组初始化过程中如果提供的初始值数量少于数组大小时
- 当不使用初始值定义一个局部静态变量时
- 当使用 `T()` 的表达式来显式请求值初始化时

聚合类使得用户可以直接访问成员，当一个类满足下面条件时，称为聚合类：

- 所有成员都是 `public` 
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，没有虚函数


----------
## 类的静态成员
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员相关的数据。静态成员不包含 `this` 指针，也不能声明成 `const` 的，类似于全局变量，静态成员一旦被定义，就将一直存在于程序运行的整个生命周期。