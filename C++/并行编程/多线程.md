# C++ 多线程
## 线程

每个程序至少有一个线程：执行main函数的线程。

----------

# C++中的线程

使用线程对象之前，要导入相应的头文件`<thread>`

----------
> 对象创建

    std::thread(函数指针或引用，（如果函数有参数的话）前面的函数实参)

注意创建对象时的参数应该是全局变量，如果是临时变量的话，则编译器不会将其解析为一个线程创建，而是一个返回类型为线程的函数。

<font color="red">好像线程的构造函数参数可以是类名，具体还有疑问，参数形式有问题</font>

----------

> 线程对象状态

线程对象在创建后销毁之前需要确定状态，否则线程对象的析构函数会调用`std::terminate()`

状态有两种：

- 加入:也就是将子线程加入主线程，主线程会等待子线程完成以后，再释放局部变量。也就是子线程的函数会先运行，子线程不需要负责释放资源，父线程结束后统一释放。进入该状态：`线程对象名.join()`
- 分离：也就是将子线程和主线程分离，子线程独立运行，有可能主线程结束，子线程依然在运行，类似于守护进程，在后台继续运行。和join的操作规则类似。进入该状态：`线程对象名.detach()`

线程对象创建后joinable为真。

子线程只能join/detach一次，因为joinable为真的时候才能join/detach，join/detach之后joinable为假。


----------
> 线程所有权转移

线程都是可以移动的，不能拷贝。（也就是原线程对象可以将本身的所有信息交给新的线程对象，原线程对象和线程就没有关系了；不能两个线程对象和同一个线程相连）

如果对一个已经有线程相连的线程对象进行所有权转移会使程序崩溃。

----------

> 系统最大并行线程数

`std::thread::hardware_concurrency()` 这个函数可以返回系统能够并行线程的最大值。

----------
> 识别线程

通过线程的id来识别线程。对应的类型是 `std::thread::id` 。

有两种方法来查找线程id：

- 使用线程对象的成员函数 `get_id()` 来直接获取，如果线程对象没有和任何线程相连则会返回 `std::thread::type` 默认构造值（测试得到会返回0）。
- 在当前线程执行中调用 `std::thread::get_id()` 可以获得当前进程id

线程id可以拷贝和比较，因为id可以复用，两个对象属于相同的线程则id相同（都是0则说明都没有线程），如果不同则代表不同的线程或者其中一个没有线程。


----------

# 数据共享

使用互斥锁机制来处理数据共享（多个线程同时对同一数据操作时的顺序问题）。

通过实例化 `std::mutex` 创建互斥量对象，调用成员函数 `lock()`来上锁， `unlock()` 来解锁。直接调用成员函数来保存互斥有时候会很麻烦（忘记解锁等），可以通过 `std::lock_guard<互斥量对象>` 来自动(构造函数会做上锁操作，析构函数会做解锁操作)上锁解锁，只要在需要互斥操作的地方前面加上声明就行，在声明作用域能一直上锁。

有时候可以通过引用或指针来访问到被互斥锁保护的数据，所以在设计接口的时候要注意。

----------
> 死锁

多个互斥量作用于同一个操作的时候，容易产生死锁。

 `std::lock` 可以一次性锁住多个互斥量而且不会产生死锁。<font color='red'>（这里可能有问题）</font>

 

----------

> std::unique_lock

`std::unique_lock` 和 `std::lock_guard` 基本一样，不过可以手动上锁开锁（第二个好像不行），更灵活，开销更大。



**还有很多内容没看懂。。**


----------
> 锁的粒度

锁的粒度越大代表锁保护的数据量越大。

就像购物结账一样，要保护的数据量就是需要结账的物品量，物品量越大，需要结账的时间就越长，也就是说粒度过大，其他同样需要访问保护数据的线程的等待时间越长，降低多线程的性能，所以使用适当粒度的锁很重要。

----------
# 同步并发

> 等待条件满足

`std::condition_variable` 和 `std::condition_variable_any` 在 `<condition_variable>` 中，用来进行条件判断。

前一个只能和 `std::mutex` 一起使用，后面一个更灵活，开销更大。





> 既然是同步，必然是有多个步骤。假设有两个步骤，第一步，向队列中插入数据；第二步，处理数据。

> 则第一步同一时间只能有一个线程访问数据，上锁(lock_guard)，操作完成后`std::condition_variable`对象的 `notify_one()` 成员函数通知等待中的线程（第二步的线程）；第二步也是先上锁（unique_lock），`std::condition_variable`对象的成员函数 `wait(条件)` 来检查是否满足触发条件，不满足条件则将解锁并将线程阻塞，满足条件就重新检查互斥量。


----------
> 等待一次性事件

c++称一次性事件为期望（future），在等待期间可能会先执行一些其他任务，直到条件触发，改变线程状态，这种状态改变是不可重置的（一次性）。

有两种（和智能指针差不多）：

- unique futures 只能关联一件事
- shared futures 可以关联多件事

<async> 会返回一个期望对象


----------
> std::packaged_task<>

**待补充**


----------
> std::promises

解决网络多线程连接



----------
# c++内存模型和原子类型操作

基本原则：

- 每一个变量都是对象
- 每一个对象至少占一个内存位置
- 基本类型都有确定（固定？）的内存位置
- 相邻位域是相同内存的一部分

----------
## 原子操作

原子操作是一类不可分割的操作，当这类操作在线程中进行中时是无法查看的，它的状态不是完成就是未完成（废话。。）。

原子类型的所有操作都是原子操作 	   --- 	`std::atomic<>`模板。

标准原子类型不能拷贝和赋值（只能初始化？引用？指针？），因为没有拷贝构造函数和拷贝赋值函数。


----------
> `std::atomic_flag`

最简单的标准原子类型，表示一个布尔标志。

这个类型的对象可以在两个状态间切换：设置和清除。

`std::atomic_flag`	类型的对象必须被 `ATOMIC_FLAG_INIT` 初始化。初始化标志位是“清除”状态。

它是唯一需要以如此特殊的方式初始化的原子类型，但它也是唯一保证无锁的类型。如果	`std::atomic_flag`	是静态存储的，那么是静态初始化的，也就意味着没有初始化顺序问题；在首次使用时，都需要初始化。

当你的标志对象已初始化，那么你只能做三件事情：


- 销毁：（没写。。自动析构？）
- 清除：`clear()`成员函数是一个存储操作，所以不能有 `memory_order_acquire` 或`memory_order_acq_rel` 语义
- 设置(查询之前的值)：`test_and_set()`成员函数可以指定好内存顺序，是一个“读-改写”操作，所有可以应用于任何内存顺序标签。

你不能拷贝构造另一个	`std::atomic_flag`	对象；并且，你不能将一个对象赋予另一 个	`std::atomic_flag`	对象。这是所有原子类型共有的： 一个原子类型的所有操作都是原子的，赋值和拷贝调用了两个对象，这就就破坏了操作的原子性。在这样的情况下，拷贝构造和拷贝赋值都会将第一个对象的值进行读取，然后再写 入另外一个。对于两个独立的对象，这里就有两个独立的操作了，合并这两个操作必定是不 原子的。因此，操作就不被允许。

----------
> `std::atomic`

最基本的原子整型类型就是	`std::atomic<bool>`	，有着比	`std::atomic_flag`	更加齐全的布尔标志特性。虽然它依旧不能拷贝构造和拷贝赋值，但是你可以使用一个非原子的布尔类型构造它，所以它可以被初始化为 `true` 或 `false` ，并且你也可以从一个非原子布尔变量赋值给	`std::atomic<bool>`	的实例：

	std::atomic<bool> b(true); 
	b=false;

有三种操作：

- `store()` 是一个存储操作
- `load()` 是一个 加载操作
- `exchange()` 是一个“读-改-写”操作



