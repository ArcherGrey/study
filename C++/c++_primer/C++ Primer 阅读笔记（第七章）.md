# C++ Primer 阅读笔记（第七章）
## 7. 类
### 7.1 定义抽象数据类型
（略）

----------

### 7.2 访问控制与封装
 `public` 说明符之后的成员可以在整个程序中被访问，定义类的接口。
 
 `private` 说明符之后的成员可以被类的成员函数访问，但是不能使用该类的代码访问，部分封装了类的实现细节。

 `class` 的默认成员是 `private`的， `struct` 是 `public`。（前面是两者之间的唯一区别，C++中 `struct`也可以添加成员函数)

> 友元

类可以允许其他类或者函数访问它的非公有成员，方法就是令其他类或者函数成为它的友元。只需要在类中增加一条以 `friend` 开头的声明语句即可。

最好在类定义开始或者结束的位置集中声明友元。

友元声明仅仅是指定访问权限，而不是通常意义上的声明。


----------

### 7.3 类的其他特性
一个 `const` 成员函数如果以引用的方式返回 `*this`，那么返回类型是常量引用。

即使两个类的成员列表完全一样，它们也是不同的类型。

只声明不定义的类是不完全类型，不能创建类的对象，这种声明叫前向声明。


----------

### 7.4 类的作用域
一个类就是一个作用域。

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域使用过，不过在类中，如果成员使用了外层作用域的某个名字，该名字代表一种类型，则类不能在之后重新定义该名字。


----------

### 7.5 构造函数
最好使用构造函数初始化，如果没有初始化列表，效率比较低。

最好令初始值的顺序和成员声明顺序保持一致，尽量避免用某些成员初始化其他成员。

如果一个构造函数为所有参数都提供了默认值，那么实际上就是默认构造函数。

对象被默认初始化或值初始化时自动执行默认构造函数，默认初始化在下面情况发生：

- 在块作用域内不使用任何初始值定义一个非静态变量或者数组时
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时
- 当类类型的成员没有在构造函数初始值列表中显式初始化时

值初始化在下面情况发生：

- 在数组初始化过程中如果提供的初始值数量少于数组大小时
- 当不使用初始值定义一个局部静态变量时
- 当使用 `T()` 的表达式来显式请求值初始化时

聚合类使得用户可以直接访问成员，当一个雷满足下面条件时，称为聚合类：

- 所有成员都是 `public` 的
- 没有定义任何构造函数
- 没有类内初始值
- 没有基类，没有虚函数

----------

### 7.6 类的静态成员
类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员相关的数据。静态成员不包含 `this` 指针，也不能声明成 `const` 的，类似于全局变量，静态成员一旦被定义，就将一直存在于程序运行的整个生命周期。
