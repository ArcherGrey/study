# C++ Primer 阅读笔记（第二章）
## 2. 变量和基本类型


----------
### 2.1 基本内置类型


----------
#### 2.1.1 算术类型
分为两类：整型和浮点型

![](http://i.imgur.com/nORHilI.png)


`float` 一个字，一般有7个有效位，`double` 两个字，一般有16个有效位

> 如何选择类型：
> 
- 明确不可能为负时，使用无符号类型
- 使用 `int` 执行整数运算
- 在算术表达式中不要使用 `char` 或 `bool`，只有在存放字符或布尔值的时候使用
- 执行浮点数运算使用 `double` ，因为 `double` 和 `float` 计算代价差不多，`float` 的精度往往不够

----------

#### 2.1.2 类型转换
类型所能表示值的范围决定了转换的类型：

- 将非布尔类型的值赋给布尔类型的时候，值为 0 则结果为 false，否则为true
- 将布尔类型的值赋给非布尔类型的时候，值为false 结果为 0， 值为true结果为 1
- 将浮点类型赋给整数类型时，进行了近似处理，结果只保留浮点数的整数部分
- 将整数类型赋给浮点类型时，小数部分为 0 ，如果整数所占空间超过了浮点类型的容量，精度可能有损失
- 当给无符号类型赋给一个超过范围的值时，结果是该值对无符号类型表示数值的总数取模后的余数，例如把 -1 赋给 `unsigned char`结果为 255
- 当赋给带符号类型一个超过范围的值时，结果是未定义的，可能继续工作或者崩溃

----------

#### 2.1.3 字面值常量
> 整型和浮点型字面值

可以将整型字面值写作十进制、八进制、十六进制形式，以 0 开头表示八进制，以 0x 或 0X 开头表示十六进制。

浮点型字面值表现为一个小数或以科学计数法来表示的指数，其中指数部分用E或e来标识

> 字符和字符串字面值

单引号括起来的称为 `char` 字面值，双引号括起来的则构成字符串型字面值。
字符串字面值的类型实际是由常量字符构成的数组，编译器会在每个字符串的结尾添加一个空字符，字符串字面值的实际长度要比它的内容多1。

> 转义序列

有两类字符不能直接使用：

- 不可打印字符，如退格或其他控制字符，因为没有可视的图符。
- 另一类是在C++中有特殊含义的字符（单引号，双引号，问号，反斜杠）

上面的情况需要使用转义序列，转义序列都是以反斜杠开始。

----------

### 2.2 变量


----------
#### 2.2.1 变量定义
基本形式： 类型说明符 + 一个或多个变量名 （变量名以逗号分隔） 分号结束

对象：一块能存储数据并具有某种类型的内存空间。

初始化：在对象创建的时候获得一个初始值。
（C++中初始化和赋值不是一个概念，赋值是把当前值擦除然后在用一个新的值代替）

列表初始化：用花括号来初始化，当初始值有丢失信息的风险时，编译器会报错。

默认初始化：如果定义变量的时候没有指定初始值，则变量会默认初始化，默认值由对应的类型决定，如果是内置类型，值由定义的位置决定，定义在函数体之外会被初始化为 0 ，定义在函数体之内将不会初始化，值是未定义的。

----------

#### 2.2.2 变量声明和定义的关系
声明使得名字为程序所知，定义负责创建与名字关联的实体。

变量声明规定了变量的类型和名称，定义还要申请空间，也可能会赋予一个初始值。

如果只想声明而不定义在变量名前面加 `extern`，可以给这样的变量赋值但是会抵消`extern`的作用变成声明加定义，任何包含显示初始化的声明都是定义。

变量只能被定义一次，可以多次被声明。

----------

#### 2.2.3 标识符
标识符由字母、数字、下划线组成，必须以字母、下划线开头，长度没有限制，对大小写敏感。

自定义标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头，定义在函数体外的标识符不能以下划线开头。（最好不要这样命名，不过不会报错）



> 变量命名规范：



> 
- 标识符要能体现实际含义
- 一般用小写字母
- 用户自定义的类名一般以大写开头
- 由多个单词组成应该有明显区分

----------

#### 2.2.4 名字的作用域

作用域一般由花括号分隔

全局作用域：可以在整个程序范围内使用

局部作用域：只能在花括号内作用

作用域可以被包含，大的作用域内的变量可以作用于小的作用域，小作用域内可以重新定义大作用域中的变量。

----------

### 2.3 复合类型

> 引用（左值引用）

引用为对象起了另外一个名字，引用必须初始化，引用会和被引用对象的值绑到一起（而不是拷贝），引用无法重新绑定到一个新的对象。

对引用的操作相当于对绑定对象的操作，但是引用本身不是对象，所以不能定义对引用的引用。

引用只能绑定到对象上，不能绑定常量或者表达式。

----------
> 指针

指针本身是一个对象，允许对指针赋值和拷贝，指针无需再定义时赋值。

指针存放某个对象的地址，想要获得地址，需要使用取地址符（&），引用不是对象没有地址，所以不能定义指向引用的指针。

指针的类型必须和指向对象的类型匹配。

指针的值只会有下面几种情况：

- 指向一个对象
- 指向对象所占空间的下一位置
- 空，没有指向任何对象
- 无效指针，任何试图访问无效指针的操作都会引发错误

如果指针指向了一个对象，可以通过解引用（*）来访问对象，如果对解引用的结果赋值，实际上就是给指针所指对象赋值。

空指针不指向任何对象，得到空指针的方法就是用nullptr来初始化指针，它可以被转换成任何其他的指针类型，另一种方法就是用 0 或者 NULL 来初始化。

赋给指针的值必须是地址，不能直接把变量赋给指针，即使变量为 0。

最好初始化所有指针。

 `void *`指针可以存放任意类型对象的地址，但是不能对所指对象直接操作。（应该就是不能解引用，只能用来存地址，不能通过地址访问对象）

----------

#### 2.3.3 理解复合类型的声明
可以将修饰符和变量名写在一起，例如 `int *a` ；也可以将类型名和修饰符写一起，例如 `int* a`

指向指针的指针，指针是内存中的对象，可以把指针的地址存放到另一个指针中，也就是指向指针的指针，要访问指向指针的指针指向的对象，需要两次解引用。同理还有指向指针的引用，离变量最近的符号对变量的类型有最直接的影响，例如 `int *&a`(从右到左阅读)

----------

### 2.4 const限定符
const对象一旦创建就不可以改变，所以必须初始化，可以用复杂的表达式或者常量来初始化。

默认状态下，const对象只在文件内有效，如果想要多个文件共享，则需要在一个文件中定义一次，在其他需要使用的文件中声明。不管是声明还是定义都要添加 `extern` 关键字。

----------

#### 2.4.1 const引用
可以把引用绑定到const对象上，但是不能通过引用来修改所绑定的对象。

----------

#### 2.4.2 指针和const
指向常量的指针不能用于修改所指对象的值。

const指针就是常量指针，一旦初始化就不能改变所指的地址。

----------

#### 2.4.3 顶层、底层const
顶层就是常量指针 例如： `int *const a `

底层就是指向常量的指针 例如： `const int *a`


----------
#### 2.4.4 constexpr和常量表达式
常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式。

`constexpr` 是让编译器来验证表达式是否为一个常量表达式的类型，声明为 `constexpr`的变量一定是一个常量，而且必须用常量表达式来初始化，`constexpr`指针是一个常量指针。

----------

### 2.5 处理类型
#### 2.5.1 类型别名
两种方法定义类型别名：

- 用 `typedef `关键字作为基本数据类型，例如：`typedef int nums; // nums 是 int 的同义词`
- 别名声明，使用 `using` 作为别名声明的开始，例如： `using nums = int; //nums 是 int 的同义词`

最好不要使用类型别名指代指针或者常量，会导致意想不到的后果。

----------

#### 2.5.2 auto类型说明符
 `auto`能够让编译器代替我们去分析表达式所属的类型，是通过初始值来推算类型，所以必须要有初始值。


----------
#### 2.5.3 decltype 类型指示符
作用是返回操作数的数据类型

----------
### 2.6 自定义数据结构
（略）