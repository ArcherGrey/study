# 选择排序
> 基本上是最简单的排序算法，步骤如下：
> 
1. 找到数组中最小的那个元素
2. 将它和数组的第一个元素交换位置
3. 在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置，循环这个过程，直到整个数组有序

> 内循环比较元素大小，外循环交换位置，每次交换都能排定一个元素，交换的总次数为数组大小，但是算法的效率取决于比较的次数。

> 长度为N的数组，选择排序需要`(n-1+1)(n-1)/2 => n(n-1)/2`比较和N次交换

## 特点


> 运行时间和输入无关

无论是有序数组还是无序的都需要比较和交换相同的次数，所以在数组有序的时候性能很差。

> 数据移动是最少的

因为每次移动都是最终位置，交换的次数和数组的大小是线性关系，这是其他算法所不具备的

## 代码实现（C++）
<pre>
void SelectionSort(vector<int> &num)
{
	int temp;
	for(int i=0; i < num.size(); ++i){
		int min=i;	
		for(int j=i+1; j < num.size(); ++j){
			if(num[j] < num[min])
				min = j;
		}
		temp = num[i];
		num[i] = num[min];
		num[min] = temp;
	}
}


</pre>


