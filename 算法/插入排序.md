# 插入排序
输入：<a1,a2,...,an>

输出：<b1,b2,...,bn> 其中b1<=b2<=b3...<=bn

插入排序对于**小规模**数组是一种很有效的排序算法。
插入排序很像人在打牌时对牌的排序。
下面是伪代码：

    INSERTION-SORT(A)

    for j=2 to A.length
    	key = A[j] //insert A[j] into A[1,..,j-1]
    	i = j-1
    	while i>0 and A[i]>A[j]
    		A[i] = A[j]
    		i = i-1
    	A[i+1] = key

我们使用**循环不变式**来帮助我们判断一个算法是否正确（类似数学归纳法）：

- 初始化：在第一次循环之前正确
- 循环中：在某次循环之前是正确的，那么下次循环之前依然是正确的。
- 终结：循环结束时，前两条正确则说明算法正确。

来看看插入排序是否正确：
- 初始化：j=2 A[1,..,j-1] = A[1]有序，所以是正确的
- 循环中：每次循环豆浆A[j]作为key与A[1,..,j-1]中的元素依次比较。比A[j]大则交换，每次循环后key插入后的A[1,...,j]依然保持有序。
- 终结：最后，当j>A.length时结束循环，保证每个元素都已经插入到数组中，所以该算法是正确的。

## 算法分析
分析一个算法需要预测算法所需要的资源。资源一般包括内存，带宽或者是其他硬件，不过主要是看花费时间。通过对同一问题使用不同的算法比较花费的时间就能得出最有效的一种算法。

## 插入排序分析
运行时间就是每一行需要执行的次数求和
最好情况是要排队列已经有序，运行时间是基于规模的线性函数。（n）
最坏情况是队列逆序，运行时间是基于规模的二次函数。（n平方）