
# 概述
 `JavaScript` 的数据类型分为两类：
- 原始类型（primitive type）：包括 [数字](#num)、字符串 和 布尔值，还有两个特殊的原始值：[null](#null) 和 [undefined](#null)
- [对象类型](#第六章待补充)（object type）：对象是属性的集合，每个属性都是由 `名/值对` （值可以是原始类型，也可以是对象类型）构成，其中比较特殊的是 [全局对象](#global)，还有 [数组](#第七章待补充) 和 [函数](#第八章待补充) 。如果通过函数来初始化一个新建对象（使用new运算符），这个函数就是构造函数，每个构造函数定义了一类对象，除了数组和函数类之外，`JavaScript` 语言核心定义了其他三种常用的类型：日期类、[正则类](#第十章待补充) 和 [错误类](#第九章待补充)

`JavaScript` 解释器有自己的内存管理机制，可以自动对内存进行垃圾回收，程序可以按需创建对象，而程序员不需要关系对象的销毁和内存回收，当不再有任何引用指向一个对象，解释器就会知道这个对象没用了，然后自动收回它所占用的资源。

`JavaScript` 是一种面向对象的语言，也就是说可以针对不同数据类型定义相应的方法来对数据进行操作。从技术上来说，只有对象才能拥有方法，但是数字、字符串和布尔值也可以拥有自己的方法（[工作机制](#3.6待补充)）。在 `JavaScript` 中只有 `null` 和 `undefined` 是无法拥有方法的值。

`JavaScript` 的变量是无类型的，变量可以被赋予任何类型的值，同样一个变量也可以重新赋予不同类型的值。使用 `var` 关键字来声明变量，`JavaScript` 采用的是词法作用域，不在函数内声明的变量称为全局变量，在整个程序的任何地方都是可见的，在函数内声明的变量具有函数作用域，并且只在函数内可见。

---------
<h1 id="num">数字</h1>

和其他编程语言不同，`JavaScript` 不区分整数和浮点数，所有的数字都用浮点数来表示，采用的是 `IEEE 754` 标准定义的64位浮点格式表示数字。

当一个数字直接出现在 `JavaScript` 程序中，我们称之为数字直接量。 `JavaScript` 支持多种格式的数字直接量。

注意，在任何数字直接量前添加负号 `-` 可以得到它的负值。但负号是一元求反运算符，并不是数字直接量语法的组成部分。

## 整型直接量

`JavaScript` 可以直接识别十进制的整型直接量，也能识别十六进制的值，十六进制的直接量以 `0x` 或 `0X` 为前缀，其后跟随十六进制的直接量。

`JavaScript` 的某些实现可以允许采用八进制表示整数，八进制直接量以 0 开始，其后跟随八进制的数字序列。

由于八进制并不是标准支持，所以最好不要使用八进制来表示。在 `ECMA Script 6` 的严格模式下，八进制直接量是明令禁止的。

## 浮点型直接量

浮点型直接量可以含有小数点，它们采用的是传统的实数写法。一个实数由整数部分、小数点、小数部分组成。

此外，还可以使用指数记数法表示浮点型直接量。

## 算术运算

`JavaScript` 中的算术运算在上溢、下溢或被零整除时不会报错。

上溢（overflow）：当数字运算结果超过了所能表示的数字上限，结果为一个特殊的值：结果为正是 `Infinity` ，结果为负是 `-Infinity` 。
下溢（underflow）：当运算结果无限接近于零并且比所能表示的最小值还小（绝对值）的时候，将会返回 `0` ，当一个负数发生下溢时返回 `-0` 。
零除以零时没有意义的，将会返回 `NaN`，还有无穷大除以无穷大、对任意负数进行开方运算或者算术运算符和不是数字或无法转换成数字的操作数一起使用时都会返回 `NaN` 。

`NaN` 和 `Infinity` 都是只读的。

`JavaScript` 中的非数字和任何值都不相等（`NaN!=NaN`），包括自身，所以不能通过 `x==NaN` 来判断 `x` 是否是 `NaN` ，应该通过 `x!=x` 来判断，只有当 `x` 为 `NaN` 时结果才是真。也可以通过 `isNaN()` 和 `isFinite()` 来判断。

## 二进制浮点数产生的问题

实数的个数有无数个，但是通过浮点数形式只能表示其中有限的个数。也就是说，在使用实数的时候，常常只是真实值的一个近似表示。

二进制表示法可以精确的表示部分分数，比如 1/2 、 1/8 。但是我们常用的分数都是十进制分数如百分之一、十分之一等。二进制浮点数表示法并不能精确表示类似 `0.1` 这样简单的数字。

例如：

```
var x = .3 - .2; // 实际结果应该是 0.1
var y = .2 - .1; // 实际结果也应该是 0.1
x == y; // 然而结果并不相等
x == .1 // false 实际结果是0.09999999999999998
y == .1 // true
```

上面的问题是由于舍入误差造成的，而且这个问题并不只会在 `JavaScript` 中出现，在任何使用二进制浮点数的编程语言中都会有这个问题。

所以在进行精确计算的时候尽量避免使用浮点数，以免造成难以预料的错误。

## 日期和时间

`JavaScript` 通过 `Date()` 构造函数来创建表示日期和时间的对象，这些对象的方法为日期计算提供了简单的API。日期对象不像数字那样是基本数据类型。

更多细节自行查阅。

# 文本

`JavaScript` 通过字符串类型来表示文本。

## 字符串直接量

`JavaScript` 中的字符串直接量，是由单引号或者双引号括起来的字符序列。

有单引号定界的字符串中可以包含双引号，反之亦然。

## 转义字符

和其他编程语言的一样。

## 字符串的使用

`JavaScript` 中字符串自带了很多功能，更多内容自行查阅。

注意：字符串是只读的。

## 模式匹配

可以百度 正则表达式。

# 布尔值

比较语句的结果就是布尔值

<h1 id="null">null 和 undefined</h1>

`null` 通常用来描述空值，它的类型是 `object`，它是 `JavaScript` 的关键字 ，也就是说它是一个特殊的对象类型，含义是“非对象”。可以用来表示数字、字符串和对象是“无值”的。

`JavaScript` 还有第二个值来表示值的空缺，用未定义的值表示更深层次的空值。它是变量的一种取值，表示变量没有 `初始化` ，如果查询对象属性或者数组元素的值时返回 `undefined` 则说明这个属性或者元素不存在；如果函数没有返回任何值，则返回 `undefined` ；引用没有提供实参的函数形参的值也会得到 `undefined` 。 `undefined` 是预定义的全局变量，和 `null` 不一样，并不是关键字，不过同样是只读的。

尽管两者有细节的不同，但是都可以表示值的空缺，两者往往可以互换，使用 `==` 来判断认为两者是相等的（`===` 可以区分它们）。在判断的时候它们都是假值（）转换成布尔值）。它们都不包含任何属性和方法。

`undefined` 常常被用来表示系统级的、出乎意料的或者类似错误的值的空缺，而 `null` 用来表示程序级、正常的或者意料之中的值的空缺。如果想将它们赋值给变量或者属性，或将它们作为参数传入函数，最佳选择是使用 `null` 。

<h1 id="global">全局对象</h1>

当 `JavaScript` 解释器启动时（或者任何浏览器加载新页面的时候），它将创建一个新的全局对象，并给它一组定义的初始属性：
- 全局属性，比如 `undefined` | `Infinite` | `NaN`
- 全局函数，比如 `isNaN()` | `eval()`
- 构造函数，比如 `Date()` | `String()`
- 全局对象，比如 `Math` | `JSON`

全局对象的初始属性并不是保留字，但应该当做保留字对待。
在代码的最顶级（不在任何函数内）可以使用关键字 `this` 来引用全局对象。
在客户端中，在浏览器窗口中的所有代码中，`Window` 对象充当了全局对象，这个全局对象有个属性 `window` 引用自身，它可以代替 `this` 来引用全局对象。`window` 对象定义了核心全局属性，但也针对浏览器和客户端定义了一少部分其他属性。

当初次创建的时候，全局对象定义了 `JavaScript` 中所有的预定义全局值，这个特殊对象同样包含了为程序定义的全局值。如果代码声明了一个全局变量，这个全局变量就是全局对象的一个属性。

# 包装对象

`JavaScript` 对象是一种复合值，它是属性或已命名值的集合，通过 `.` 符号来引用属性值，当属性值是一个函数的时候，称其为方法，通过 `o.m()` 来调用对象 `o` 中的 `m` 方法。

可以看到在字符串中也可以使用相同的调用方式，字符串不是对象，为何能这样使用呢？
只要引用了字符串的属性，就会将字符串值通过调用 `new String(s)` 的方式转换成对象，这个对象继承了字符串的方法，并被用来处理属性的引用，一旦属性引用结束，这个新创建的对象就会销毁（其实在实现上并不一定创建或销毁这个临时对象，但是整个过程看起来是这样）。

同字符串一样，数字和布尔值也有各自的方法：通过 `Number()` 和 `Boolean()` 构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。而 `null` 和 `undefined` 没有包装对象：访问它们的属性会造成一个类型错误。

```
var s = "test"; // 创建一个字符串
s.len = 4; // 给它设置一个属性
var t = s.len; // 查询这个属性
```
 
运行上面的代码时， `t` 会是 `undefined` 。第二行会创建一个临时字符串对象，并对其 `len` 属性赋值为4，随即销毁这个对象。第三行通过原始的字符串对象创建一个新的临时字符串对象，尝试读取其 `len` 属性，这个属性自然是 `undefined` 。这段代码说明在读取字符串、数字和布尔值的属性值（或者方法）的时候，表现的和对象一样。但是如果试图对其属性进行赋值，则会忽略这个操作，修改的只是临时对象的属性，而临时对象并没有继续保存下来。

存取字符串、数字或者布尔值的属性时创建的临时对象称为 `包装对象`，它只是偶尔用来区分字符串值和字符串对象、数字和数字对象以及布尔值和布尔对象。通常，包装对象只是被看做一种实现细节，而不用特别关注。由于字符串、数字和布尔值的属性都是只读的，并且不能给它们定义新属性，所以还是有别于对象的。

还可以通过 `String()` | `Number()` | `Boolean()` 构造函数来显示创建包装对象。

[包装对象详解](https://github.com/ArcherGrey/study/blob/master/JavaScript/%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1.md)

# 不可变的原始值和可变的对象引用

`JavaScript` 中的原始值和对象有着根本区别：
- 原始值不可更改，对象的值是可以修改的
- 原始值的比较是值的比较，只有在它们值相等的时候才相等。对象的比较并非是值的比较，即使两个对象包含同样的属性和相同的值，它们也不是相等的，通常将对象那个称为引用类型，对象值都是引用的，对象的比较应该是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。

# 类型转换







