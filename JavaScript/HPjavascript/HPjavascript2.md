# 数据访问

数据存储在哪里，关系到代码运行期间数据被检索到的速度。在javascript中这个问题相对简单，因为数据存储是少量方式可以选择。

javascript 中有四种基本的数据访问位置：
- 直接量：包括字符串、数字、布尔值、对象、数组、函数、正则表达式，具有特殊意义的空值（null）以及未定义（undefined）
- 变量：var 关键字创建
- 数组：具有数字索引
- 对象：具有字符串索引

大多数情况下，对一个直接量和一个局部变量数据访问的性能差异是微不足道的。访问数组和对象的代价要更高一些，具体差距多少依赖于浏览器。

## 管理作用域

作用域概念是理解javascript的关键，不仅从性能的角度而且从功能的角度。作用域对javascript有许多影响，从确定那些变量可以被函数访问，到确定this的值。作用域也关系到性能。

每一个javascript函数都可以看作一个对象，换一句话说它是一个函数实例。函数对象和其他对象一样，有可以访问的属性和一系列不能被访问的仅供javascript引擎使用的内部属性，其中一个内部属性是 `scope`。

`scope`属性包含一个函数被创建的作用域中对象的集合。此集合被称为函数的作用域链，它决定那些数据可以被函数访问。函数作用域链中的每一个对象被称为一个可变对象，每一个可变对象都以 `key/value` 的形式存在。当一个函数被创建之后，它的作用域链被填充以对象，这些对象代表创建此函数的环境中可以访问的对象。

例子：
```
function add(num1, num2){
var sum = num1 + num2;
return sum;
}
```

`add` 函数创建后，它的作用域链中填入一个单独可变对象，这个对象代表了所有全局范围定义的变量。（也就是提供了一个接口来访问全局定义的变量）

在调用函数的时候会建立一个内部对象，称为运行时上下文。一个运行时上下文定义了一个函数运行时的环境。函数每次调用，都会创建不同的运行时上下文，所以多次调用同一个函数就会导致多次创建运行时上下文。当函数执行完毕，运行时上下文就会被销毁。

一个运行时上下文有自己的作用域链，用于标识符解析。当运行时上下文被创建的时候，它的作用域链被初始化。在函数运行过程中，每遇到一个变量，标识符识别过程决定从哪里获得或者存储数据，此过程搜索运行时上下文的作用域链，查找同名标识符。这种搜索过程往往会影响性能。

标识符的位置越深，读写速度越慢，所以局部变量的速度总是最快的，全局变量的速度通常是最慢的。（全局变量总是位于作用域链的最后一个位置，不过好像chrome浏览器都差不多，因为v8的优化很好）

所以在没有优化javascript引擎的浏览器中，尽可能的使用局部变量。

一般来说，一个运行时上下文的作用域链不会被改变，但是有两种方法可以临时改变：
- with 关键字，最好不要使用影响性能
- catch 子句 最好不要在子句内访问局部变量

## 动态作用域
无论是 with 还是 catch 子句还有包含 `()` 的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（代码结构）来确定是否存在动态作用域。

例子：
```
function execute(code) {
(code);
function subroutine(){
return window;
}
var w = subroutine();
//what value is w?
};
```

大多数情况下，w将等价于全局window对象，不过在 `execute("var window={};")` 的情况下，会在函数中创建一个局部的window变量，所以不允许这段代码是没有办法预先确定标识符的确切含义的。

所以在绝对必要的时候才推荐使用动态作用域。

## 闭包、作用域、内存
通常一个函数的激活对象和运行时上下文一同被销毁，但是涉及闭包的时候，激活对象就无法被销毁，因为引用依然存在于闭包的属性中，这意味着脚本中的闭包和非闭包函数相比，需要更多的内存开销，特别是在大型网页应用中，这会是一个严重的问题，同时还有可能导致内存泄漏的问题。

脚本中最好小心的使用闭包。

## 对象成员
大多数javascript代码以面向对象的形式编写，因此存在很多对象成员访问。

对象成员包括属性和方法，在javascript中，两者差别甚微，对象的一个命名成员可以包含任何数据类型，既然函数也是一种对象，那么也可以包含一个函数，当一个命名成员引用了一个函数时，它被称为一个 `方法`，而一个非函数类型的数据则被称为 `属性`。

对象成员比直接量或局部变量的访问速度要慢，在某些浏览器上甚至比数组还要慢，其中的原因就是javascript中的对象的性质决定的。

### 原形

javascript中的对象是基于原形的，原形是其他对象的基础，定义并实现一个新对象必须具有的成员。原形对象为所有给定类型的对象实例所共享，因此所有实例共享原形对象的成员。

一个对象通过一个内部属性绑定到它的原形，开发人员可以通过 `chrome` | `firefox` | `safari`浏览器看到 `__proto__`。任何时候你创建一个内置类型的实例，这些实例自动拥有一个 `object` 作为它们的原形。

因此，对象可以有两种类型的成员：
- 实例成员：存在于实例本身
- 原形成员：从对象原形继承

### 原形链
对象的原形决定了一个实例的类型，默认情况下，所有对象都是object的实例，并继承了所有基本方法。

例子：
```
function Book(title, publisher){
this.title = title;
this.publisher = publisher;
}
Book.prototype.sayTitle = function(){
alert(this.title);
};
var book1 = new Book("High Performance JavaScript", "Yahoo! Press");
var book2 = new Book("JavaScript: The Good Parts", "Yahoo! Press");
alert(book1 instanceof Book); //true
alert(book1 instanceof Object); //true
book1.sayTitle(); //"High Performance JavaScript"
alert(book1.toString()); //"[object Object]"
```

Book 构造器用于创建一个新的实例， `book1.__proto__` 是 `Book.prototype`
