# 响应接口

大多数浏览器只有一个单独的处理进程，由两个任务共享：javascript任务和用户界面更新任务。每个时刻只有一个操作可以执行，也就是说在javascript代码运行时用户界面不能对输入产生反应，反之亦然。

## UI线程

javascript和UI更新共享的进程通常被称为浏览器的UI线程。此线程围绕一个简单的队列系统工作，任务被保存到队列中直至进程空闲，一旦空闲队列中的下一个任务将被检索和运行。这些任务不是执行javascript代码就是执行UI更新，包括重绘和重排版。

也就是说javascript任务必须尽快结束，以免对用户体验造成不良影响。

浏览器在javascript运行时间上采取了限制，确保恶意代码编写者不能通过无尽的密集操作锁定用户浏览器或计算机，此类限制有两个：调用栈尺寸限制和长时间脚本限制。当一个脚本的运行时间达到一定限度就会被浏览器终止，同时会向用户显示一个对话框提示。

浏览器有两种方法测量脚本的运行时间：
- 统计自脚本开始运行以来执行了多少条语句。此方法意味着脚本在不同的机器上可能会运行不同的时间长度，可用内存和CPU速度可以影响一条独立语句运行所花费的时间
- 统计脚本运行的总时间。在特定时间内可运行的脚本数量和用户机器性能差异而不同，但脚本总是在固定的时间上被终止

不同浏览器的限制：
- IE 设置默认限制500万条语句，限制放在注册表中
- firefox 默认限制为10秒，存放在浏览器配置中
- Safari 默认限制为5秒
- chrome 没有独立的长运行脚本限制，而是依赖通用崩溃检测系统来处理此类实例
- opera 没有长运行脚本限制

当浏览器的长时间脚本限制被触发，有一个对话框显示给用户，而不管页面上的任何其他错误处理代码，这是一个主要的可用性问题，因为大多数互联网用户并不精通技术，会被错误信息所迷惑，不知道该停止脚本或允许它继续运行。

从开发者的观点看，没有办法改变长运行脚本对话框的外观，所以最好的办法就是避免长运行脚本。

一个单一的javascript操作应当使用的总时间应该是100毫秒，如果超过100毫秒，用户会认为自己和接口断开了。

有些时候一些javascript任务因为复杂性原因不能在100毫秒以内完成，这种情况下理想的方法是让出UI线程控制，所以我们需要定时器。

### 定时器

定时器代码复位所有相关浏览器限制，包括长运行脚本时间以及调用栈，这一特性使得定时器成为长运行javascript代码理想的跨浏览器解决方案。

javascript 定时器延时往往不准确，快慢大约几毫秒。windows 系统上定时器分辨率为15毫秒，也就是说一个值为15的定时器延时将根据最后一次系统时间刷新而转换为 0 或者 15。设置定时器延时小于 15 将在ie中导致浏览器锁定，所以最小值建议大于15毫秒。

### 分解任务
我们通常将一个任务分解成一系列子任务。如果一个函数运行时间太长，那么查看它是否可以分解成一系列能够短时间完成的较小的函数。可将一行代码简单地看作一个原子任务，多行代码组合在一起构成一个独立任务。某些函数可基于函数调用进行拆分。

如果函数运行时间太长，它可以拆分成一系列更小的步骤，把独立方法放在定时器中调用。你可以将每个函数都放入一个数组，然后使用前一节中提到的数组处理模式。


## 网页工人线程（web workers）

网页工人线程对网页应用来说是一个潜在的巨大性能提升，因为新的工人线程在自己的线程中运行javascript，这意味着工人线程中的代码运行不仅不会影响到浏览器的UI，而且也不会影响其他工人线程中运行的代码。

由于网页工人线程不绑定UI线程，也意味着它们不能访问许多浏览器资源。每个工人线程都有自己的全局运行环境，只有javascript特性的一个子集可用，由下面部分组成：
- 一个浏览器对象，包括四个属性：appName,appVersion,userAgent,platform
- 一个 location 对象
- 一个 self 对象指向全局工人线程对象
- 一个 importScript() 方法，使得工人线程可以加载外部javascript 文件
- 所有javascript对象
- xmlhttprequest 构造器
- settimeout 和 setInterval
- close() 方法结束工人线程


网页工人线程有不同的全局环境，必须要创建一个完全独立的javascript文件，包含那些在工人线程中运行的代码，要创建工人线程，必须要传入这个文件的URL：
```
var worker = new Worker("code.js")
```
此代码一旦执行，将为指定文件创建一个新县城和一个新的工人线程运行环境，此文件被异步下载，下载运行完成后才启动工人线程。

### 工人线程交互

工人线程和网页代码通过事件接口进行交互，网页代码可通过 postMessage() 方法向工人线程传递数据。工人线程中有 onmessage 事件句柄用于接收信息：
```
var worker = new Worker("code.js");
worker.onmessage = function(event){
alert(event.data);
};
worker.postMessage("Nicholas");
```
消息系统是页面和工人线程之间唯一的交互途径。

当工人线程通过importScripts()方法加载外部JavaScript 文件，它接收一个或多个URL 参数，指出要加载的JavaScript 文件网址。工人线程以阻塞方式调用importScripts()，直到所有文件加载完成并执行之后，脚本才继续运行。由于工人线程在UI 线程之外运行，这种阻塞不会影响UI 响应

### 用途

网页工人线程适合于那些纯数据的，或者与浏览器UI 没关系的长运行脚本。它看起来用处不大，而网页应用程序中通常有一些数据处理功能将受益于工人线程，而不是定时器。

可能受益的任务：
- 编码、解码一个大字符串
- 负责的数学运算
- 给一个大数组排序

## 总结

- JavaScript 运行时间不应该超过100 毫秒。过长的运行时间导致UI 更新出现可察觉的延迟，从而对整体用户体验产生负面影响
- JavaScript 运行期间，浏览器响应用户交互的行为存在差异。无论如何，JavaScript 长时间运行将导致用户体验混乱和脱节
- 定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成一系列较小的任务
- 网页工人线程是新式浏览器才支持的特性，它允许你在UI 线程之外运行JavaScript 代码而避免锁定UI
- 网页应用程序越复杂，积极主动地管理UI 线程就越显得重要。没有什么JavaScript 代码可以重要到允许影响用户体验的程度
